---
title: "EJA population genomics"
author: "Arthur Oulès"
date: "2/1/2023"
format: html
editor: source
---

# Load packages

```{r}
#| echo: false

# Mandatory
library(here)
library(tidyverse)

# Data analysis
library(pcadapt)
library(vcfR)
library(adegenet)
library(ape)
library(LEA)

# External data acquisition for maps
library(ncdf4)
library(rnaturalearth)
library(rnaturalearthdata)
library(rnaturalearthhires)
library(marmap)

# External data acquisition for outliers BLAST
library(rentrez) #Allows to navigate NCBI database
library(xml2) #Allows xml file manipulation

# Making graph
library(patchwork)
library(plotly)
library(sf)
library(ggrepel)
library(ggpubr)
library(ggspatial)
library(RColorBrewer)
library(viridis)
library(scales)
library(ggnewscale)
```

# pcadapt analysis

## Load data analysis functions

```{r}
source(here("functions", "tidy_functions.R"))
```

## All loci

### pcadapt pre-analysis to chose K value for outliers selection

```{r}
EJA_all_loci <- read.pcadapt(# Vcf file from ustacks populations output is expected
  here(
    "data",
    "ustacks_populations_output",
    "all_loci",
    "populations.snps.vcf"
  ),
  type = "vcf"
)

pcadapt(input = EJA_all_loci, K = 20) |>
  plot(option = "screeplot") # screeplot to visually choose pca component to keep
```

K = 3 seems to be the most optimal number of PCA axes to keep for this data set.

### Analysis with K = 3

```{r}
pcadapt_all_loci <- pcadapt(input = EJA_all_loci, K = 3)

popmap <- c(
  rep("carmel", 6),
  rep("monterey", 18),
  rep("palos_verdes", 9),
  rep("laguna", 9),
  rep("san_diego", 22),
  rep("catalina", 8),
  rep("punta_banda", 20),
  rep("cardon", 3)
) #map individuals to populations

plot(pcadapt_all_loci, option = "scores", pop = popmap, i = 1, j = 2)
plot(pcadapt_all_loci, option = "scores", pop = popmap, i = 2, j = 3)
plot(pcadapt_all_loci, option = "scores", pop = popmap, i = 1, j = 3)

plot(pcadapt_all_loci, option = "qqplot")
hist(
  pcadapt_all_loci$pvalues,
  xlab   = "p-values",
  main   = NULL,
  breaks = 50,
  col    = "orange"
)
```

### Outliers identification

```{r}
EJA_outliers_ranks <- Get_outliers(
  vcf_path      = here("data", "ustacks_populations_output", "all_loci",
                       "populations.snps.vcf"),
  phistats_path = here("data", "ustacks_populations_output", "all_loci",
                       "populations.phistats.tsv"),
  pcadapt       = pcadapt_all_loci,
  filename      = "EJA"
)
```

### Protein sequences acquisition for all loci analysis outliers

#### Import and format the catalog

```{r}
EJA_outliers_sequences <- Get_catalog_sequences(
  here("data", "catalog.fa"),
  outliers_ranks = EJA_outliers_ranks,
  filename       = "EJA_outliers_sequences"
)
```

Please run an NCBI nBLAST analysis with the generated .fa file and download the result as Single-file XML2.

#### Import BLAST results saved as xml file and extract results

Please replace the second line of the XML file by <BlastXML2> which effectively removes the metadata from the first xml tag.

```{r}
EJA_outliers_blast_tib <- here("data", "8R1WY2TK01N-Alignment.xml") |> # "Single-file XML2" file from NCBI BLASTn output is expected
  read_xml() |>
  XML_to_df()
EJA_outliers_blast_tib |> saveRDS(
  file = here("output", "EJA_outliers_nBlast_results_as_tibble.RDS")
)
```

#### Filter BLAST results

```{r}
EJA_outliers_blast_tib_80_PREDICTED <- EJA_outliers_query_tib |>
  filter(bit_score >= 80) |> # Keep only significant matches
  filter(grepl("PREDICTED", title)) |> # Keep only PREDICTED proteins. Removes non coding sequences and whole chromosome matches (causes problem when searching GeneBank)
  filter(!duplicated(Rank)) |> # Keep the first match for each locus
  filter(!duplicated(accession_number))  # Removes duplicated accession numbers

print(
  paste0(
    "There are ",
    dim(EJA_outliers_blast_tib_80_PREDICTED)[1],
    "outliers of interest."
  )
)

EJA_outliers_blast_tib_80_PREDICTED |> write.csv(
  file = here("output", "EJA_outliers_blast_tib_80_PREDICTED.csv")
)
```

#### Get protein sequences from GenBank and remove miss

```{r}
# query_df <- readRDS(here("output", "Blast_results_as_data_frame.RDS"))
EJA_outliers_protein_sequences_matches <- EJA_outliers_blast_tib_80_PREDICTED |>
  Get_protein_sequences()
```

#### Save output as fasta file which can be sent to [blast KOALA](https://www.kegg.jp/blastkoala/).

```{r}
#Write protein sequences as fasta file with GenBank access number as sequence names
sink(here("output", "EJA_outliers_protein_sequences.fa"))
for (i in 1:dim(EJA_outliers_protein_sequences_matches[1])){
  cat(
    paste0(">", EJA_outliers_protein_sequences_matches$accession_number[i], "\n"),
    append = TRUE
  )
  cat(
    paste0(EJA_outliers_protein_sequences_matches$sequences[i], "\n"),
    append = TRUE
  )
}
sink()
```

#### Save outliers protein match table

```{r}
Table_2 <- EJA_outliers_blast_tib_80_PREDICTED |> 
  select(c(Rank, accession_number, title)) |>
  rename(Locus_ID = Rank) |>
  write.csv(file = here("output", "Table_2.csv"), row.names = FALSE)
```

## Blacklist (neutral loci)

```{r}
pcadapt_blacklist <- read.pcadapt( # vcf file from pcadapt analysis output is expected
  here(
    "data",
    "ustacks_populations_output",
    "EJA_blacklist",
    "populations.snps.vcf"
  ),
  type = "vcf"
) |> pcadapt(K = 20)

plot(pcadapt_blacklist, option = "screeplot")
plot(pcadapt_blacklist, option = "scores", pop = popmap, i = 1, j = 2)
```

## Whitelist (outliers loci)

```{r}
EJA_whitelist <- read.pcadapt( # vcf file from pcadapt analysis output is expected
  here(
    "data",
    "ustacks_populations_output",
    "EJA_whitelist_outliers",
    "populations.snps.vcf"
  ),
  type = "vcf"
)
pcadapt_whitelist <- pcadapt(input = EJA_whitelist, K = 20)

plot(pcadapt_whitelist, option = "screeplot")
plot(pcadapt_whitelist, option = "scores", pop = popmap, i = 1, j = 2)
```

## Analysis excluding Catalina

### pcadapt pre-analysis to chose K value

```{r}
EJA_all_loci_catalina <- read.pcadapt( # vcf file from pcadapt analysis output is expected
  here(
    "data",
    "ustacks_populations_output",
    "EJA_all_loci-catalina",
    "populations.snps.vcf"
  ),
  type = "vcf"
)

pcadapt_all_loci_catalina_raw <- pcadapt(input = EJA_all_loci_catalina, K = 20) #pcadapt analysis with high value of K
plot(pcadapt_all_loci_catalina_raw, option = "screeplot") #screeplot to visually chose pca component to keep
```

K = 2 seems to be the most optimal for this data set

### pcadapt analysis with K = 2

```{r}
pcadapt_all_loci_catalina <- pcadapt(input = EJA_all_loci_catalina, K = 2)

popmap <- c(
  rep("carmel", 6),
  rep("monterey", 18),
  rep("palos_verdes", 9),
  rep("laguna", 9),
  rep("san_diego", 22),
  rep("punta_banda", 20),
  rep("cardon", 3)
) #map individuals to populations

plot(
  pcadapt_all_loci_catalina,
  option = "scores",
  pop = popmap,
  i = 1, j = 2
)
100*pcadapt_all_loci_catalina$singular.values**2
```

### Outliers identification excluding Catalina

```{r}
EJA_catalina_outliers_ranks <- Get_outliers(
  vcf_path = here(
    "data",
    "ustacks_populations_output",
    "EJA_all_loci-catalian"
  ),
  pcadapt  = pcadapt_all_loci_catalina,
  filename = "EJA_catalina"
)
```

## Using low coverage data

### Using all populations

#### Convert vcf to bed file using plink2

```{bash}
cd C:/Users/aoules/Desktop/R_projects/Surfperch_GenPop/plink2

./plink2 --vcf 8-Embiotoca_filtered.vcf.gz --make-bed --out 8-Embiotoca_filtered
```

#### Preanalysis to determine optimal K value

```{r}
EJA_lcwgs <- read.pcadapt(
  here("data", "lcwgs", "8-Embiotoca_filtered.bed"),
  type = "bed"
)

pcadapt(input = EJA_lcwgs, K = 20) |>
  plot(option = "screeplot")
```

K = 4 seems correct

#### Analysis using K = 4

```{r}
popmap_lcwgs <- c(
  rep("bodega_bay", 5), # BB
  rep("big_creek", 13), # BIGC -> BCR
  rep("catalina_island", 11), # CAT
  rep("elkhorn", 6), # ELK
  rep("guadalupe_island", 10), # GUA
  rep("lovers_point", 13), # HOP -> Pacific Grove PGR 
  rep("isla_san_jeronimo", 11), # ISJ
  rep("laguna_beach", 13), # LB
  rep("point_dume", 5), # PD
  rep("santa_barbara_island", 13), # SB
  rep("san_clemente_island", 10), # SCL
  rep("la_jolla_san_diego", 13), # SD
  rep("tomales_bay", 1), # TB
  rep("redondo_beach", 10), # RB
  rep("santa_cruz_harbour", 10) # SCH
)

pcadapt_lcwgs <- EJA_lcwgs |> pcadapt(K = 4)
```

#### Associated exploratory plots

```{r}
pcadapt_lcwgs |> plot(option = "scores", pop = popmap_lcwgs, i = 1, j = 2)
pcadapt_lcwgs |> plot(option = "scores", pop = popmap_lcwgs, i = 2, j = 3)
pcadapt_lcwgs |> plot(option = "scores", pop = popmap_lcwgs, i = 3, j = 4)

pcadapt_lcwgs |> plot(option = "qqplot")

pcadapt_lcwgs |> plot(option = "manhattan")

pcadapt_lcwgs$pvalues |> hist(
  xlab   = "p-values",
  main   = NULL,
  breaks = 50,
  col    = "orange"
)
```

### Generating whitelist

```{r}
EJA_lcwgs_vcf |>
  vcfR2tidy() |> 
  _$gt$Indiv |> 
  unique() |>
  {\(x) {
    x[!(grepl(pattern = "SCL", x = x) | grepl(pattern = "GUA", x = x) | grepl(pattern = "CAT", x = x))]}
  }() |> 
  paste(collapse = "\n") |> 
  write_file(here("plink2", "whitelist.txt"))
```

### Excluding islanders
#### Generating bed file
```{bash}
cd C:/Users/aoules/Desktop/R_projects/Surfperch_GenPop/plink2

./plink2 --bfile 8-Embiotoca_filtered --keep whitelist.txt --make-bed --out 8-Embiotoca_filtered_whitelisted
```

#### Preanalysis to determine optimal K value

```{r}
EJA_lcwgs_coast <- read.pcadapt(
  here("data", "lcwgs", "8-Embiotoca_filtered_whitelisted.bed"),
  type = "bed"
)

pcadapt(input = EJA_lcwgs_coast, K = 20) |>
  plot(option = "screeplot")
```

K = 4 seems correct

#### Analysis using K = 3

```{r}
popmap_lcwgs_coast <- c(
  rep("bodega_bay", 5), # BB
  rep("big_creek", 13), # BIGC -> BCR
  rep("elkhorn", 6), # ELK
  rep("lovers_point", 13), # HOP -> Pacific Grove PGR 
  rep("isla_san_jeronimo", 11), # ISJ
  rep("laguna_beach", 13), # LB
  rep("point_dume", 5), # PD
  rep("santa_barbara_island", 13), # SB
  rep("la_jolla_san_diego", 13), # SD
  rep("tomales_bay", 1), # TB
  rep("redondo_beach", 10), # RB
  rep("santa_cruz_harbour", 10) # SCH
)

pcadapt_lcwgs_coast <- EJA_lcwgs_coast |> pcadapt(K = 3)
```

#### Associated exploratory plots

```{r}
coast_PCA_1_2 <- pcadapt_lcwgs_coast |> plot(
  option = "scores",
  pop    = popmap_lcwgs_coast,
  i = 1, j = 2
) +
  theme_minimal()

save_open_plot(
  here("output", "plots", "lcwgs", "coast_PCA_1_2.pdf"),
  plot   = coast_PCA_1_2,
  width  = 10,
  height = 8
)

coast_PCA_2_3 <- pcadapt_lcwgs_coast |> plot(
  option = "scores",
  pop    = popmap_lcwgs_coast,
  i = 2, j = 3
) +
  theme_minimal()

save_open_plot(
  here("output", "plots", "lcwgs", "coast_PCA_2_3.pdf"),
  plot   = coast_PCA_2_3,
  width  = 10,
  height = 8
)

pcadapt_lcwgs_coast |> plot(option = "qqplot") + theme_minimal()

coast_manhattan <- pcadapt_lcwgs_coast |>
  plot(option = "manhattan") + theme_minimal()

save_open_plot(
  here("output", "plots", "lcwgs", "coast_manhattan.pdf"),
  plot   = coast_manhattan,
  width  = 16,
  height = 4
)

pcadapt_lcwgs_coast$pvalues |> hist(
  xlab   = "p-values",
  main   = NULL,
  breaks = 50,
  col    = "orange"
)
```

### Using only islanders

#### Generating bed file
```{bash}
cd C:/Users/aoules/Desktop/R_projects/Surfperch_GenPop/plink2

./plink2 --bfile 8-Embiotoca_filtered --remove whitelist.txt --make-bed --out 8-Embiotoca_filtered_blacklisted
```

#### Preanalysis to determine optimal K value

```{r}
EJA_lcwgs_islands <- read.pcadapt(
  here("data", "lcwgs", "8-Embiotoca_filtered_blacklisted.bed"),
  type = "bed"
)

pcadapt(input = EJA_lcwgs_islands, K = 2) |> plot(option = "screeplot")
```

#### Analysis using K = 2

```{r}
popmap_lcwgs_islands <- c(
  rep("catalina_island", 11), # CAT
  rep("guadalupe_island", 10), # GUA
  rep("san_clemente_island", 10) # SCL
)

pcadapt_lcwgs_islands <- EJA_lcwgs_islands |> pcadapt(K = 2)
```

#### Associated exploratory plots

```{r}
islands_PCA_1_2 <- pcadapt_lcwgs_islands |> plot(
  option = "scores",
  pop    = popmap_lcwgs_islands,
  i = 1, j = 2
) +
  theme_minimal()

save_open_plot(
  here("output", "plots", "lcwgs", "islands_PCA_1_2.pdf"),
  plot   = islands_PCA_1_2,
  width  = 10,
  height = 8
)

pcadapt_lcwgs_islands |> plot(option = "qqplot") + theme_minimal()

islands_manhattan <- pcadapt_lcwgs_islands |>
  plot(option = "manhattan") + theme_minimal()

save_open_plot(
  here("output", "plots", "lcwgs", "islands_manhattan.pdf"),
  plot   = islands_manhattan,
  width  = 16,
  height = 4
)

pcadapt_lcwgs_islands$pvalues |> hist(
  xlab   = "p-values",
  main   = NULL,
  breaks = 50,
  col    = "orange"
)
```
# Admixture analysis

## Convert data to ped format for LEA import using plink2
```{bash}
cd C:/Users/aoules/Desktop/R_projects/Surfperch_GenPop/plink2
./plink2 --vcf 8-Embiotoca_filtered.vcf.gz --export ped --out 8-Embiotoca_filtered
```

## Read and convert data
```{r}
EJA_lcwgs_tb <- EJA_lcwgs_vcf |>
  vcfR2tidy()

ped2geno(
  input.file  = here("plink2", "8-Embiotoca_filtered.ped"),
  output.file = here("data", "lcwgs", "8-Embiotoca_filtered.geno")
)
```

## Run analysis
```{r}
snmf_analysis <- snmf(
  here("data", "lcwgs", "8-Embiotoca_filtered.geno"),
  project = "continue",
  K       = 5:8,
  entropy = TRUE
)
```

## Plot cross entropy to chose value of K
```{r}
plot(snmf_analysis)
```

## Rerun multiple times
```{r}
snmf_analysis <- snmf(
  here("data", "lcwgs", "8-Embiotoca_filtered.geno"),
  project     = "continue",
  repetitions = 100,
  K           = 6,
  entropy     = TRUE
)
```

## Plot results for K = 6
```{r}
barchart(
  snmf_analysis,
  K         = 6,
  run       = which.min(cross.entropy(snmf_analysis, K = 6)),
  col       = viridis(n = 6, option = "turbo"),
  sort.by.Q = FALSE
)
```

## Pretty plot
```{r}
ID_ordered <- read.table(here("data", "lcwgs", "Individuals_plot_order.txt")) |> unlist() |> as.vector() 
admixture_plot <- read_table(
  here("data", "lcwgs", "8-Embiotoca_filtered.snmf", "K6", "run1",
       "8-Embiotoca_filtered_r1.6.Q"),
  col_names = paste0("Pop ", seq(1, 6))
) |> 
  mutate(Individuals = EJA_lcwgs_tb$gt$Indiv |> unique()) |> 
  relocate(Individuals) |> 
  pivot_longer(
    -c(Individuals),
    names_to  = "Populations",
    values_to = "Ancestry proportions"
  ) |> 
  ggplot(
    aes(
      x    = factor(
        Individuals,
        levels = ID_ordered
      ),
      y    = `Ancestry proportions`,
      fill = Populations
    )
  ) +
  geom_col(position = "stack", width = 1) +
  scale_fill_viridis(discrete = TRUE, option = "turbo") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 8, angle = 90, vjust = 0.5, hjust = 1)
  )

save_open_plot(
  path   = here("output", "plots", "lcwgs", "admixture_plot_K=6.pdf"),
  plot   = admixture_plot,
  width  = 16,
  height = 6
  )
```

# Figures

## Load plotting functions

```{r}
source(here("functions", "plot_functions.R"))
```

## Figure 1 - Manhattan plot home-made

### RADs

#### Getting data

```{r}
EJA_all_loci_vcf <- here("data", "ustacks_populations_output", "all_loci",
                         "populations.snps.vcf") |>
  read.vcfR() # vcf file from pcadapt analysis output is expected
```

#### Generate plot without labels

```{r}
manhattan_plot <- manhattan_plot_custom(
  vcf_file         = EJA_all_loci_vcf,
  pcadapt_analysis = pcadapt_all_loci,
  n_chromosome     = 24
)

save_open_plot(
  here("output", "plots", "manhattan_plot.pdf"),
  plot   = manhattan_plot,
  width  = 16,
  height = 7
)
```

#### Generate plot with labels

```{r}
manhattan_plot_labels <- manhattan_plot_custom(
  vcf_file         = EJA_all_loci_vcf,
  pcadapt_analysis = pcadapt_all_loci,
  n_chromosome     = 24,
  outliers_ranks   = EJA_outliers_ranks
)

save_open_plot(
  here("output", "plots", "manhattan_plot_labels.pdf"),
  plot   = manhattan_plot_labels,
  width  = 16,
  height = 7
)
```

### Low coverage

#### Getting data

```{r}
plot(pcadapt_lcwgs, option = "manhattan")
```

```{r}
EJA_lcwgs_vcf <- here("data", "lcwgs", "8-Embiotoca.pruned.vcf.gz") |>
  read.vcfR() # vcf file used in pcadapt analysis output is expected
```

#### Generate plot without labels

```{r}
manhattan_plot <- manhattan_plot_custom(
  vcf_file         = EJA_lcwgs_vcf,
  pcadapt_analysis = pcadapt_lcwgs,
  n_chromosome     = 24
)

save_open_plot(
  here("output", "plots", "lcwgs", "manhattan_plot.pdf"),
  plot   = manhattan_plot,
  width  = 16,
  height = 7
)

rm(manhattan_plot)
```

#### Generate plot with labels

```{r}
manhattan_plot_labels <- manhattan_plot_custom(
  vcf_file         = EJA_all_loci_vcf,
  pcadapt_analysis = pcadapt_all_loci,
  n_chromosome     = 24,
  outliers_ranks   = EJA_outliers_ranks
)

save_open_plot(
  here("output", "plots", "manhattan_plot_labels.pdf"),
  plot   = manhattan_plot_labels,
  width  = 16,
  height = 7
)
```

## Figure 2 - PCA & map

### RADs

#### PCA plot

```{r}
PCA <- PCA_plot(
  pcadapt_output = pcadapt_all_loci,
  popmap         = popmap,
  x_offsets      = c(0, -.02, .015, 0, 0, 0, 0, 0),
  y_offsets      = c(.04, .01, -.01, .06, .06, .06, .055, .045)
)
```

#### Surface temperature and current map

##### Getting data

Surface temperature and current speed come from the [BRAN2020](https://research.csiro.au/bluelink/global/reanalysis/) [Dataset](https://dapds00.nci.org.au/thredds/catalog/gb6/BRAN/BRAN2020/catalog.html).\
[Tutorial on NetCDF4 files](https://towardsdatascience.com/how-to-crack-open-netcdf-files-in-r-and-extract-data-as-time-series-24107b70dcd).

```{r}
nc_temp <- nc_open(here("data","ocean_temp_ann_2022.nc"))
# Longitude's 0 is at Greenwich and -180 become 3600
# Latitudes start at -75 and end at +75
# To convert add +360 to longitude and +75 to latitude
nc_u   <- nc_open(here("data", "ocean_u_ann_2022.nc"))
nc_v   <- nc_open(here("data", "ocean_v_ann_2022.nc"))
```

##### Formatting data

###### BRAN2020 data

```{r}
# Coordinates of interest
lon_min <- -130.0
lon_max <- -110.0
lat_min <- 20.0
lat_max <- 40.0

# Convert coordinate system
lon <- nc_temp |> ncvar_get("xt_ocean")
lon[1801:3600] <- seq(-179.95, -0.05, .1)

lat <- nc_temp |> ncvar_get("yt_ocean")

# Fuse for use in ggplot and crop to smaller size for faster computing time
crop_lonlat <- expand.grid(
  "lon" = lon[(3600 + 10 * lon_min):(3600 + 10 * lon_max)],
  "lat" = lat[(750  + 10 * lat_min):(750  + 10 * lat_max)]
)

crop_temp <- nc_temp |> nc_crop(lon_min, lon_max, lat_min, lat_max)

crop_u_lowres <- nc_u |>
  nc_crop(lon_min, lon_max, lat_min, lat_max) |> 
  reduce_density(2)

crop_v_lowres <- nc_v |>
  nc_crop(lon_min, lon_max, lat_min, lat_max) |> 
  reduce_density(2)

map_data_lowres_df <- crop_lonlat |>
  mutate("temp" = crop_temp, "u" = crop_u_lowres, "v" = crop_v_lowres)

current_uv_scalar <- 2 # Set scalar for better vector visibility, don"t forget when setting scale in final graph
```

###### Landmass

```{r}
# Setting up landmass map from naturalearth
states <- ne_states(
  country     = c("united states of america", "mexico"),
  returnclass = "sf"
)

# Sampling site coordinates and misc info on map
sample_sites <- read.csv(
    here("data","EJA_RAD_sampling_sites.csv"),
    stringsAsFactors = FALSE
  ) |>
  filter(!duplicated(Sampling_location)) |> 
  mutate( # Add offsets
    "lab_lon" = Longitude + .15 + c(0, 0, 0, .1, 0, 0, 0, -.1 -2),
    "lab_lat" = Latitude + .25 + c(0, -.5, 0, -.2, 0, 0, 0, -.1 -1)
  )

states_labels <- data.frame(
  "long" = c(-117.5, -115.5, -113.7, -115.2),
  "lat"  = c(35.5, 36.6, 35, 30.25),
  "lab"  = c("CA", "NV", "AZ", "BC")
)
city_labels <- data.frame(
  "lat"      = c(37.773972, 34.448113),
  "long"     = c(-122.431297, -120.471439),
  "lat_lab"  = c(37.9, 34.8),
  "long_lab" = c(-122.28, -120.535),
  "lab"      = c("San Francisco", "Point\nConception")
)
ocean_labels <- data.frame(
  "long" = c(-121,-113.85),
  "lat"  = c(31,30.7),
  "lab"  = c("Pacific Ocean","Gulf\nof\nCalifornia")
)
```

##### Generate map

[Tutorial for surface temperature and current speed map](https://theoceancode.netlify.app/post/mapping_with_ggplot2/)

```{r}
map <- ggplot() +
  # Temperature map
  geom_tile(
    mapping = aes(x = lon, y = lat, fill = temp),
    data    =  map_data_lowres_df
  ) +
  # Temperature scale
  scale_fill_viridis(name = "Temp.\n(°C)", option = "turbo") +
  # Current vectors
  geom_segment(
    data    = map_data_lowres_df,
    mapping = aes(
      x    = lon,
      y    = lat,
      xend = lon + current_uv_scalar * u,
      yend = lat + current_uv_scalar * v
    ),
    arrow   = arrow(angle = 15, length = unit(0.035, "inches"), type = "closed"),
    na.rm   = TRUE,
    alpha   = 0.3
  ) +
  # Landmass
  geom_sf(data = states) +
  # Crop map
  coord_sf(xlim = c(-124, -113), ylim = c(28.5, 38.5), expand = FALSE) +
  # Sampling sites points and labels
  new_scale("fill") +
  geom_path( # Path from Catalina label to Catalina island
    data.frame(
      "x" = c(-118.4163, -118.4163 -.85),
      "y" = c(33.38790, 33.38790 -.73)
    ),
    mapping = aes(x, y)
  ) +
  geom_point(
    sample_sites,
    mapping     = aes(
      x = Longitude,
      y = Latitude,
      fill = Sampling_location,
      size = 1.3
    ),
    shape       = 21,
    show.legend = FALSE
  ) +
  geom_label(
    sample_sites,
    mapping = aes(x = lab_lon, y = lab_lat, label = Sampling_location),
    hjust   = 0
  ) +
  # Extra cities points and labels
  geom_point(
    city_labels,
    mapping     = aes(x = long, y = lat),
    size        = 4,
    shape       = 20,
    show.legend = FALSE
  ) +
  geom_text(
    city_labels,
    mapping    = aes(x = long_lab, y = lat_lab, label = lab),
    lineheight = .7,
    hjust      = 0
  ) +
  # Ocean and state names
  geom_text(
    states_labels,
    mapping = aes(x = long, y = lat, label = lab),
    size = 5.5
  ) +
  geom_text(
    ocean_labels[2, ],
    mapping = aes(x = long, y = lat, label = lab),
    colour  = "ivory",
    size    = 5
  ) +
  geom_label(
    ocean_labels[1, ],
    mapping       = aes(x = long, y = lat, label = lab),
    colour        = "black",
    size          = 5,
    label.padding = unit(0.5, "lines")
  ) +
  # Vector scale
  geom_label(
    aes(x = -122, y = 29.5, label = "1.0 m/s\n"),
    size          = 4.5,
    label.padding = unit(0.5, "lines")
  ) +
  geom_segment(
    aes(x = -122.5, y = 29.25, xend = -121.5, yend = 29.25),
    arrow = arrow(angle = 15, length = unit(0.035, "inches"), type = "closed")
  ) +
  # Cartographic scale
  geom_label(aes(x = -119.1, y = 28.71, label = "        ")) +
  annotation_scale(location = "bl", width_hint = 0.4) +
  # Orientation
  annotation_north_arrow(
    location = "tr",
    style = north_arrow_fancy_orienteering()
  ) +
  # Axes
  labs(x = "Longitude", y = "Latitude") +
  scale_x_continuous(
    breaks = c(-120, -115),
    labels = c("120°W", "115°W")
  ) +
  scale_y_continuous(
    breaks = c(30, 35),
    labels = unit_format(suffix = "°N", sep = "")
  )

save_open_plot(
  here("output", "plots", "temp_current_map.pdf"),
  plot   = map,
  width  = 9,
  height = 9
)
```

#### Memory cleanup

```{r}
rm(nc_temp, nc_u, nc_v,
   lon, lat,
   crop_temp, crop_u_lowres, crop_v_lowres,
   map, states,
   sample_sites, states_labels, city_labels, ocean_labels,
   current_uv_scalar)
gc()
```

#### Fuse PCA plot and map

```{r}
PCA_map <- ggarrange(PCA, map, widths = c(1, 1.3))

save_open_plot(
  here("output", "plots", "pca_map.pdf"),
  plot   = PCA_map,
  width  = 14,
  height = 9
)
```

### Low coverage

#### PCA plot

```{r}
PCA <- PCA_plot(pcadapt_output = pcadapt_lcwgs, popmap = popmap_lcwgs)
PCA

save_open_plot(
  path   = here("output", "plots", "lcwgs", "PCA.pdf"),
  plot   = PCA,
  width  = 9,
  height = 9
)

PCA_plot(
  pcadapt_output = pcadapt_lcwgs,
  popmap         = popmap_lcwgs,
  x_offsets      = rep(.01, 15),
  y_offsets      = rep(.05, 15)
) |>
  ggplotly()

PCA
```

```{r}
PCA_crop <- PCA + xlim(-.065, -.05) + ylim(.1125, .1275) +
  coord_fixed(ratio = 1) +
  theme(
    legend.position = "none",
    axis.title      = element_blank(),
    plot.background = element_rect(fill = "white", linetype = "longdash")
  )
PCA_crop$layers[[2]] <- NULL

PCA_and_crop <- PCA + annotate(
  "rect",
  xmin  = -.07, xmax = -.04,
  ymin  = .1075, ymax = .1325,
  alpha = 0, colour = "black", linetype = "longdash"
) + 
theme(legend.position = "none") +
inset_element(PCA_crop, left = 0.6, bottom = 0.6, right = 1, top = 1)

save_open_plot(
  path   = here("output", "plots", "lcwgs", "pca_crop.pdf"),
  plot   = PCA_and_crop,
  width  = 9,
  height = 9
)
```

#### Surface temperature and current map

##### Getting data

Surface temperature and current speed come from the [BRAN2020](https://research.csiro.au/bluelink/global/reanalysis/) [Dataset](https://dapds00.nci.org.au/thredds/catalog/gb6/BRAN/BRAN2020/catalog.html).\
[Tutorial on NetCDF4 files](https://towardsdatascience.com/how-to-crack-open-netcdf-files-in-r-and-extract-data-as-time-series-24107b70dcd).

```{r}
nc_temp <- nc_open(here("data","ocean_temp_ann_2022.nc"))
# Longitude's 0 is at Greenwich and -180 become 3600
# Latitudes start at -75 and end at +75
# To convert add +360 to longitude and +75 to latitude
nc_u   <- nc_open(here("data", "ocean_u_ann_2022.nc"))
nc_v   <- nc_open(here("data", "ocean_v_ann_2022.nc"))
```

##### Formatting data

###### BRAN2020 data

```{r}
# Coordinates of interest
lon_min <- -130.0
lon_max <- -110.0
lat_min <- 20.0
lat_max <- 40.0

# Convert coordinate system
lon <- nc_temp |> ncvar_get("xt_ocean")
lon[1801:3600] <- seq(-179.95, -0.05, .1)

lat <- nc_temp |> ncvar_get("yt_ocean")

# Fuse for use in ggplot and crop to smaller size for faster computing time
crop_lonlat <- expand.grid(
  "lon" = lon[(3600 + 10 * lon_min):(3600 + 10 * lon_max)],
  "lat" = lat[(750  + 10 * lat_min):(750  + 10 * lat_max)]
)

crop_temp <- nc_temp |> nc_crop(lon_min, lon_max, lat_min, lat_max)

crop_u_lowres <- nc_u |>
  nc_crop(lon_min, lon_max, lat_min, lat_max) |> 
  reduce_density(2)

crop_v_lowres <- nc_v |>
  nc_crop(lon_min, lon_max, lat_min, lat_max) |> 
  reduce_density(2)

map_data_lowres_df <- crop_lonlat |>
  mutate("temp" = crop_temp, "u" = crop_u_lowres, "v" = crop_v_lowres)

current_uv_scalar <- 2 # Set scalar for better vector visibility, don"t forget when setting scale in final graph
```

###### Landmass

```{r}
# Setting up landmass map from naturalearth
states <- ne_states(
  country     = c("united states of america", "mexico"),
  returnclass = "sf"
)

# Sampling site coordinates and misc info on map
sample_sites <- read.csv2(
    here("data","low_coverage_sampling.csv"),
    stringsAsFactors = FALSE
  ) |>
  select(Longitude, Latitude, Sampling_sites) |> 
  mutate( # Add offsets
    Sampling_sites = gsub("\\n", "\n", Sampling_sites, fixed = TRUE),
    lab_lon = Longitude + .15 + rep(0, 5),
    lab_lat = Latitude + .25 + rep(0, 5)
  )

states_labels <- data.frame(
  "long" = c(-117.5, -115.5, -113.7, -115.2),
  "lat"  = c(35.5, 36.6, 35, 30.75),
  "lab"  = c("CA", "NV", "AZ", "BC")
)
city_labels <- data.frame(
  "lat"      = c(37.773972, 34.448113),
  "long"     = c(-122.431297, -120.471439),
  "lat_lab"  = c(37.7, 34.8),
  "long_lab" = c(-122.28, -120.535),
  "lab"      = c("San Francisco", "Point\nConception")
)
ocean_labels <- data.frame(
  "long" = c(-121,-113.85),
  "lat"  = c(31,30.7),
  "lab"  = c("Pacific Ocean","Gulf\nof\nCalifornia")
)
```

##### Generate map

[Tutorial for surface temperature and current speed map](https://theoceancode.netlify.app/post/mapping_with_ggplot2/)

```{r}
lcwgs_map <- ggplot() +
  # Temperature map
  geom_tile(
    mapping = aes(x = lon, y = lat, fill = temp),
    data    =  map_data_lowres_df
  ) +
  # Temperature scale
  scale_fill_viridis(name = "Temp.\n(°C)", option = "turbo") +
  # Current vectors
  geom_segment(
    data    = map_data_lowres_df,
    mapping = aes(
      x    = lon,
      y    = lat,
      xend = lon + current_uv_scalar * u,
      yend = lat + current_uv_scalar * v
    ),
    arrow   = arrow(angle = 15, length = unit(0.035, "inches"), type = "closed"),
    na.rm   = TRUE,
    alpha   = 0.3
  ) +
  # Landmass
  geom_sf(data = states) +
  # Crop map
  coord_sf(xlim = c(-124, -113), ylim = c(28.5, 38.5), expand = FALSE) +
  # Sampling sites points and labels
  new_scale("fill") +
  # geom_path( # Path from Catalina label to Catalina island
  #   data.frame(
  #     "x" = c(-118.4163, -118.4163 -.85),
  #     "y" = c(33.38790, 33.38790 -.73)
  #   ),
  #   mapping = aes(x, y)
  # ) +
  geom_point(
    sample_sites,
    mapping     = aes(x    = Longitude,
                      y    = Latitude,
                      fill = Sampling_sites,
                      size = 1.3),
    shape       = 21,
    show.legend = FALSE
  ) +
  geom_label_repel(
    sample_sites,
    mapping = aes(x = Longitude, y = Latitude, label = Sampling_sites)
  ) +
  # Extra cities points and labels
  geom_point(
    city_labels,
    mapping     = aes(x = long, y = lat),
    size        = 4,
    shape       = 20,
    show.legend = FALSE
  ) +
  geom_text(
    city_labels,
    mapping    = aes(x = long_lab, y = lat_lab, label = lab),
    lineheight = .7,
    hjust      = 0
  ) +
  # Ocean and state names
  geom_text(
    states_labels,
    mapping = aes(x = long, y = lat, label = lab),
    size = 5.5
  ) +
  geom_text(
    ocean_labels[2, ],
    mapping = aes(x = long, y = lat, label = lab),
    colour  = "ivory",
    size    = 5
  ) +
  geom_label(
    ocean_labels[1, ],
    mapping       = aes(x = long, y = lat, label = lab),
    colour        = "black",
    size          = 5,
    label.padding = unit(0.5, "lines")
  ) +
  # Vector scale
  geom_label(
    aes(x = -122, y = 29.5, label = "1.0 m/s\n"),
    size          = 4.5,
    label.padding = unit(0.5, "lines")
  ) +
  geom_segment(
    aes(x = -122.5, y = 29.25, xend = -121.5, yend = 29.25),
    arrow = arrow(angle = 15, length = unit(0.035, "inches"), type = "closed")
  ) +
  # Cartographic scale
  geom_label(aes(x = -119.1, y = 28.71, label = "        ")) +
  annotation_scale(location = "bl", width_hint = 0.4) +
  # Orientation
  annotation_north_arrow(
    location = "tr",
    style = north_arrow_fancy_orienteering()
  ) +
  # Axes
  labs(x = "Longitude", y = "Latitude") +
  scale_x_continuous(
    breaks = c(-120, -115),
    labels = c("120°W", "115°W")
  ) +
  scale_y_continuous(
    breaks = c(30, 35),
    labels = unit_format(suffix = "°N", sep = "")
  )

save_open_plot(
  here("output", "plots", "lcwgs", "temp_current_map.pdf"),
  plot   = lcwgs_map,
  width  = 9,
  height = 9
)
```

#### Memory cleanup

```{r}
rm(nc_temp, nc_u, nc_v,
   lon, lat,
   crop_temp, crop_u_lowres, crop_v_lowres,
   map, states,
   sample_sites, states_labels, city_labels, ocean_labels,
   current_uv_scalar)
gc()
```

#### Fuse PCA plot and map

```{r}
PCA_map <- PCA_and_crop + lcwgs_map +
  plot_annotation(tag_levels = list(c("A", "", "B"))) &
  theme(
    text      = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.tag = element_text(face = "bold")
    )

save_open_plot(
  here("output", "plots", "lcwgs", "pca_map.pdf"),
  plot   = PCA_map,
  width  = 14,
  height = 9
)
```

## Figure 3? - Bathymetry

### Generating bathymetry map

#### Getting and formatting data

```{r}
nc_u   <- nc_open(here("data", "ocean_u_ann_2022.nc"))
nc_v   <- nc_open(here("data", "ocean_v_ann_2022.nc"))

crop_u <- nc_u |>
  nc_crop(lon_min, lon_max, lat_min, lat_max)
crop_v <- nc_v |>
  nc_crop(lon_min, lon_max, lat_min, lat_max)
```

```{r}
catalina_df <-
  getNOAA.bathy(
    lon1 = -121,
    lon2 = -116,
    lat1 = 32,
    lat2 = 35,
    resolution = .5
  ) |> 
  fortify.bathy() |>
  mutate(z = ifelse(z > 0, NA, z)) # Remove landmass data

map_data_df <- data.frame( # Get surface current vectors
  crop_lonlat,
  "u" = crop_u,
  "v" = crop_v
)
```

#### Generate map

```{r}
bathy <- ggplot() +
  # Plot bathymetry
  geom_raster(data = catalina_df, mapping = aes(x = x, y = y, fill = z)) +
  # Plot landmass
  geom_sf(data = states) +
  # Plot surface current speed
  geom_segment(
    data    = map_data_df,
    mapping = aes(x = lon, y = lat, xend = lon + u * 1, yend = lat + v * 1),
    arrow   = arrow(angle = 15, length = unit(0.04, "inches"), type = "closed"),
    na.rm   = TRUE,
    alpha   = 0.3
  ) +
  # Plot sampling sites
  geom_point(
    sample_sites[c(3,4,5,8),],
    mapping     = aes(x = Longitude, y = Latitude, size = 1.3),
    show.legend = FALSE
  ) +
  geom_label(
    sample_sites[c(3,4,5,8),],
    mapping = aes(x = Longitude, y = Latitude, label = Sampling_location),
    hjust   = 0,
    nudge_x = .05,
    nudge_y = .1
  ) +
  # Plot extra landmark
  geom_point(
    city_labels[2, ],
    mapping     = aes(x = long, y = lat),
    size        = 4,
    shape       = 20,
    show.legend = FALSE
  ) +
  geom_text(
    city_labels[2, ],
    mapping = aes(x = long, y = lat, label = lab),
    lineheight = .7,
    hjust = 0,
    nudge_x = .05,
    nudge_y = .1
  ) +
  # Plot scales
  scale_fill_gradient(
    name = "Depth (m)",
    low = "dodgerblue4",
    high="gainsboro"
  ) +
  geom_label(
    aes(x = -120.4, y = 32.3, label = ".25 m/s\n"),
    size = 4.5,
    label.padding = unit(0.5, "lines")
  ) +
  geom_segment(
    aes(x = -120.52, y = 32.25, xend = -120.27, yend = 32.25),
    arrow = arrow(angle = 15, length = unit(0.04, "inches"), type = "closed")
  ) +
  geom_label(aes(x = -119.705, y = 32.08, label = "        ")) +
  annotation_scale(location = "bl", width_hint = 0.4) +
  annotation_north_arrow(
    location = "tr",
    style    = north_arrow_fancy_orienteering()
  ) +
  # Crop map
  coord_sf(xlim = c(-121, -116), ylim = c(32, 35), expand = FALSE) +
  # Axis labels and theme
  labs(x = "Longitude", y = "Latitude") +
  scale_y_continuous(
    breaks = seq(32, 35, 1),
    labels = unit_format(suffix = "°N", sep = "")
  ) +
  theme(
    legend.position = c(.93, .73),
    plot.margin     = margin(t = 0, r = 1, b = 0, l = .5, unit = "cm")
  )

save_open_plot(
  here("output", "plots", "bathy.pdf"),
  plot   = bathy,
  width  = 9,
  height = 7
)
```

## Blank map

```{r}
map_blank <- ggplot() +
  # Landmass
  geom_sf(data = states) +
  # Sampling sites points and labels
  new_scale("fill") +
  geom_path(
    mapping = aes(x, y),
    data    = data.frame(
      "x" = c(-118.4163, -118.4163 -.85),
      "y" = c(33.38790, 33.38790 -.73)
    )
  ) +
  geom_point(
    sample_sites,
    mapping     = aes(
      x    = Longitude,
      y    = Latitude,
      fill = Sampling_location,
      size = 1.3
    ),
    shape       = 21,
    show.legend = FALSE
  ) +
  geom_label(
    sample_sites,
    mapping = aes(x = lab_lon, y = lab_lat, label = Sampling_location),
    hjust   = 0
  ) +
  geom_point(
    city_labels,
    mapping     = aes(x = long, y = lat),
    size        = 4,
    shape       = 20,
    show.legend = FALSE
  ) +
  geom_text(
    city_labels,
    mapping    = aes(x = long_lab, y = lat_lab, label = lab),
    lineheight = .7,
    hjust      = 0
  ) +
  # Ocean and state names
  geom_text(
    states_labels,
    mapping = aes(x = long, y = lat, label = lab),
    size    = 5.5
  ) +
  geom_text(
    ocean_labels[2,],
    mapping = aes(x = long, y = lat, label = lab),
    colour  = "ivory",
    size    = 5
  ) +
  geom_label(
    ocean_labels[1,],
    mapping       = aes(x = long, y = lat, label = lab),
    colour        = "black",
    size          = 5,
    label.padding = unit(0.5, "lines")
  ) +
  # Crop map 
  coord_sf(xlim = c(-124, -113), ylim = c(28.5, 38.5), expand = FALSE) +
  # Vector, temperature and distance scale + orientation
  geom_label(aes(x = -119.1, y = 28.71, label = "        ")) +
  annotation_scale(location = "bl", width_hint = 0.4) +
  annotation_north_arrow(
    location = "tr",
    style = north_arrow_fancy_orienteering()
  ) +
  # Set text around map and coordinates display
  labs(x = "Longitude", y = "Latitude") +
  scale_x_continuous(
    breaks = c(-120, -115),
    labels = c("120°W","115°W")
  ) +
  scale_y_continuous(
    breaks = c(30, 35),
    labels = unit_format(suffix = "°N", sep = "")
  ) +
  theme(panel.background = element_rect("lightblue"))

save_open_plot(
  here("output", "plots", "map_blank.pdf"),
  plot   = map_blank,
  width  = 7.5,
  height = 7.5
)
```

## Figure 4? - Protein sequences annotation

### Convert blast KOALA pie piechart in barplot

```{r}
koala_results <- read.csv( # File downloaded from https://www.kegg.jp/blastkoala/ is expected
  here("external_results", "Blast_koala_results.csv"),
  stringsAsFactors = FALSE
) |>
  mutate(
    Functional.category = factor(Functional.category, Functional.category)
  )

koala_barplot <- ggplot(
    koala_results,
    mapping = aes(
      x    = Functional.category,
      y    = Counts,
      fill = Functional.category
    )
  ) +
  geom_col() +
  scale_fill_manual(
    name   = "Functional category",
    labels = koala_results$Functional.category,
    values = koala_results$colour,
    breaks = koala_results$Functional.category
  ) +
  theme(
    panel.background   = element_rect(fill = "white", colour = "black"),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_line(
      colour    = "black",
      linetype  = "solid",
      linewidth = .12
    ),
    panel.grid.minor.y = element_line(
      colour    = "black",
      linetype  = "dashed",
      linewidth = .08
    ),
    axis.ticks.x      = element_blank(),
    axis.text.x       = element_blank(),
    axis.title.x      = element_blank()
  )

save_open_plot(
  here("external_results", "blast_koala_bar_plot.pdf"),
  plot   = koala_barplot,
  width  = 8,
  height = 4
)
```

# vcf manipulations

```{r}
vcf_info <- EJA_lcwgs_vcf |> getFIX() |> as_tibble()

chromosomes_length_plot <- vcf_info |>
  # arrange(desc(n)) |>
  ggplot() +
  geom_bar(aes(x = factor(CHROM, levels = CHROM |> unique()))) +
  labs(x = "Chromosomes", y = "Length") +
  theme_classic() +
  theme(axis.text.x = element_text(size = 6, angle = 90, vjust = 0.5, hjust = 1))

save_open_plot(
  here("output", "plots", "lcwgs", "chromosomes_length.pdf"),
  plot   = chromosomes_length_plot,
  width  = 16,
  height = 4
)
```

```{r}
# test_matrix <- EJA_lcwgs_vcf |>
#   extract.gt() |> 
#   read.pcadapt()
# 
# test_matrix |> pcadapt(K = 20) |> plot(option = "screeplot")
# 
# test |> pcadapt(K = 4) |> plot(option = "scores", pop = popmap_lcwgs, i = 1, j = 2)
```
