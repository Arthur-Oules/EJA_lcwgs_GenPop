---
title: "EJA population genomics"
author: "Arthur Oulès"
date: "2/1/2023"
format: html
editor: source
---

# Load packages

```{r}
#| echo: false

# Mandatory
library(here)

# Data analysis
library(pcadapt)
library(vcfR)
library(adegenet)
library(ape)

# External data acquisition for maps
library(ncdf4)
library(rnaturalearth)
library(rnaturalearthdata)
library(rnaturalearthhires)
library(marmap)

# External data acquisition for outliers BLAST
library(rentrez) #Allows to navigate NCBI database
library(xml2) #Allows xml file manipulation

# Making graph
library(tidyverse)
library(sf)
library(ggrepel)
library(ggpubr)
library(ggspatial)
library(RColorBrewer)
library(viridis)
library(scales)
library(ggnewscale)
```

# pcadapt analysis

## Load data analysis functions

```{r}
source(here("functions", "tidy_functions.R"))
```

## All loci

### pcadapt pre-analysis to chose K value for outliers selection

```{r}
EJA_all_loci <- read.pcadapt(# Vcf file from ustacks populations output is expected
  here(
    "data",
    "ustacks_populations_output",
    "all_loci",
    "populations.snps.vcf"
  ),
  type = "vcf"
)

pcadapt(input = EJA_all_loci, K = 20) |>
  plot(option = "screeplot") # screeplot to visually choose pca component to keep
```

K = 3 seems to be the most optimal number of PCA axes to keep for this data set.

### Analysis with K = 3

```{r}
pcadapt_all_loci <- pcadapt(input = EJA_all_loci, K = 3)

popmap <- c(
  rep("carmel", 6),
  rep("monterey", 18),
  rep("palos_verdes", 9),
  rep("laguna", 9),
  rep("san_diego", 22),
  rep("catalina", 8),
  rep("punta_banda", 20),
  rep("cardon", 3)
) #map individuals to populations

plot(pcadapt_all_loci, option = "scores", pop = popmap, i = 1, j = 2)
plot(pcadapt_all_loci, option = "scores", pop = popmap, i = 2, j = 3)
plot(pcadapt_all_loci, option = "scores", pop = popmap, i = 1, j = 3)

plot(pcadapt_all_loci, option = "qqplot")
hist(
  pcadapt_all_loci$pvalues,
  xlab   = "p-values",
  main   = NULL,
  breaks = 50,
  col    = "orange"
)
```

### Outliers identification

```{r}
EJA_outliers_ranks <- Get_outliers(
  here("data", "ustacks_populations_output", "all_loci"),
  pcadapt  = pcadapt_all_loci,
  filename = "EJA"
)
```

### Protein sequences acquisition for all loci analysis outliers

#### Import and format the catalog

```{r}
EJA_outliers_sequences <- Get_catalog_sequences(
  here("data", "catalog.fa"),
  outliers_ranks = EJA_outliers_ranks,
  filename       = "EJA_outliers_sequences"
)
```

Please run an NCBI nBLAST analysis with the generated .fa file and download the result as Single-file XML2.

#### Import BLAST results saved as xml file and extract results

Please replace the second line of the XML file by <BlastXML2> which effectively removes the metadata from the first xml tag.

```{r}
EJA_outliers_query_df <- here("data", "8R1WY2TK01N-Alignment.xml") |> # "Single-file XML2" file from NCBI BLASTn output is expected
  read_xml() |>
  XML_to_DF()
EJA_outliers_query_df |> saveRDS(
  file = here("output", "EJA_outliers_nBlast_results_as_data_frame.RDS")
)
```

#### Filter BLAST results

```{r}
query_df_80_PREDICTED_unique_unique <- query_df |>
  filter(bit_score >= 80) |> # Keep only significant matches
  filter(grepl("PREDICTED", title)) |> # Keep only PREDICTED proteins. Removes non coding sequences and whole chromosome matches (causes problem when searching GeneBank)
  filter(!duplicated(query_number)) |> # Keep the first match for each locus
  filter(!duplicated(accession_number))  # Removes duplicated accession numbers

dim(query_df_80_PREDICTED_unique_unique)[1]

query_df_80_PREDICTED_unique_unique |> write.csv(
  file = here("output", "query_df_80_PREDICTED_unique_unique.csv")
)
```

#### Get protein sequences from GenBank and remove miss

```{r}
# query_df <- readRDS(here("output", "Blast_results_as_data_frame.RDS"))
EJA_outliers_protein_sequences_matches <- Get_protein_sequences(
  query_df_80_PREDICTED_unique_unique
) |>
  filter(!sequences == "")
```

#### Save output as fasta file which can be sent to [blast KOALA](https://www.kegg.jp/blastkoala/).

```{r}
#Write protein sequences as fasta file with GenBank access number as sequence names
sink(here("output", "EJA_outliers_protein_sequences.fa"))
for (i in 1:dim(EJA_outliers_protein_sequences_matches[1])){
  cat(
    paste0(">", EJA_outliers_protein_sequences_matches$accession_number[i], "\n"),
    append = TRUE
  )
  cat(
    paste0(EJA_outliers_protein_sequences_matches$sequences[i], "\n"),
    append = TRUE
  )
}
sink()
```

#### Save outliers protein match table

```{r}
Table_2 <- query_df_80_PREDICTED_unique_unique |> 
  select(c(query_number, accession_number, title)) |>
  rename(Locus_ID = query_number) |>
  write.csv(file = here("output", "Table_2.csv"), row.names = FALSE)
```

## Blacklist (neutral loci)

```{r}
pcadapt_blacklist <- read.pcadapt( # vcf file from pcadapt analysis output is expected
  here(
    "data",
    "ustacks_populations_output",
    "EJA_blacklist",
    "populations.snps.vcf"
  ),
  type = "vcf"
) |> pcadapt(K = 20)

plot(pcadapt_blacklist, option = "screeplot")
plot(pcadapt_blacklist, option = "scores", pop = popmap, i = 1, j = 2)
```

## Whitelist (outliers loci)

```{r}
EJA_whitelist <- read.pcadapt( # vcf file from pcadapt analysis output is expected
  here(
    "data",
    "ustacks_populations_output",
    "EJA_whitelist_outliers",
    "populations.snps.vcf"
  ),
  type = "vcf"
)
pcadapt_whitelist <- pcadapt(input = EJA_whitelist, K = 20)

plot(pcadapt_whitelist, option = "screeplot")
plot(pcadapt_whitelist, option = "scores", pop = popmap, i = 1, j = 2)
```

## Analysis excluding Catalina

### pcadapt pre-analysis to chose K value

```{r}
EJA_all_loci_catalina <- read.pcadapt( # vcf file from pcadapt analysis output is expected
  here(
    "data",
    "ustacks_populations_output",
    "EJA_all_loci-catalina",
    "populations.snps.vcf"
  ),
  type = "vcf"
)

pcadapt_all_loci_catalina_raw <- pcadapt(input = EJA_all_loci_catalina, K = 20) #pcadapt analysis with high value of K
plot(pcadapt_all_loci_catalina_raw, option = "screeplot") #screeplot to visually chose pca component to keep
```

K = 2 seems to be the most optimal for this data set

### pcadapt analysis with K = 2

```{r}
pcadapt_all_loci_catalina <- pcadapt(input = EJA_all_loci_catalina, K = 2)

popmap <- c(
  rep("carmel", 6),
  rep("monterey", 18),
  rep("palos_verdes", 9),
  rep("laguna", 9),
  rep("san_diego", 22),
  rep("punta_banda", 20),
  rep("cardon", 3)
) #map individuals to populations

plot(
  pcadapt_all_loci_catalina,
  option = "scores",
  pop = popmap,
  i = 1, j = 2
)
100*pcadapt_all_loci_catalina$singular.values**2
```

### Outliers identification excluding Catalina

```{r}
EJA_catalina_outliers_ranks <- Get_outliers(
  vcf_path = here(
    "data",
    "ustacks_populations_output",
    "EJA_all_loci-catalian"
  ),
  pcadapt  = pcadapt_all_loci_catalina,
  filename = "EJA_catalina",
  save     = FALSE
)
```

# Figures

## Load plotting functions

```{r}
source(here("functions", "plot_functions.R"))
```

## Figure 1 - Manhattan plot home-made

### Getting data

```{r}
EJA_all_loci_vcf <- here(
  "data",
  "ustacks_populations_output",
  "all_loci",
  "populations.snps.vcf"
) |>
  read.vcfR() # vcf file from pcadapt analysis output is expected
```

### Generate plot without labels

```{r}
manhattan_plot <- manhattan_plot_custom(
  vcf_file         = EJA_all_loci_vcf,
  pcadapt_analysis = pcadapt_all_loci,
  n_chromosome     = 24
)

save_open_plot(
  here("output", "plots", "manhattan_plot.pdf"),
  plot   = manhattan_plot,
  width  = 16,
  height = 7
)
```

### Generate plot with labels

```{r}
manhattan_plot_labels <- manhattan_plot_custom(
  vcf_file         = EJA_all_loci_vcf,
  pcadapt_analysis = pcadapt_all_loci,
  n_chromosome     = 24,
  outliers_ranks   = EJA_outliers_ranks
)

save_open_plot(
  here("output", "plots", "manhattan_plot_labels.pdf"),
  plot   = manhattan_plot_labels,
  width  = 16,
  height = 7
)
```

## Figure 2 - PCA & map

### PCA plot

```{r}
PCA <- PCA_plot(
  pcadapt_output = pcadapt_all_loci,
  popmap         = popmap,
  x_offsets      = c(0, -.02, .015, 0, 0, 0, 0, 0),
  y_offsets      = c(.04, .01, -.01, .06, .06, .06, .055, .045)
)
```

### Surface temperature and current map

#### Getting data

Surface temperature and current speed come from the [BRAN2020](https://research.csiro.au/bluelink/global/reanalysis/) [Dataset](https://dapds00.nci.org.au/thredds/catalog/gb6/BRAN/BRAN2020/catalog.html).\
[Tutorial on NetCDF4 files](https://towardsdatascience.com/how-to-crack-open-netcdf-files-in-r-and-extract-data-as-time-series-24107b70dcd).

```{r}
nc_temp <- nc_open(here("data","ocean_temp_ann_2022.nc"))
# Longitude's 0 is at Greenwich and -180 become 3600
# Latitudes start at -75 and end at +75
# To convert add +360 to longitude and +75 to latitude
nc_u   <- nc_open(here("data", "ocean_u_ann_2022.nc"))
nc_v   <- nc_open(here("data", "ocean_v_ann_2022.nc"))
```

#### Formatting data

##### BRAN2020 data

```{r}
# Coordinates of interest
lon_min <- -130.0
lon_max <- -110.0
lat_min <- 20.0
lat_max <- 40.0

# Convert coordinate system
lon <- nc_temp |> ncvar_get("xt_ocean")
lon[1801:3600] <- seq(-179.95, -0.05, .1)

lat <- nc_temp |> ncvar_get("yt_ocean")

# Fuse for use in ggplot and crop to smaller size for faster computing time
crop_lonlat <- expand.grid(
  "lon" = lon[(3600 + 10 * lon_min):(3600 + 10 * lon_max)],
  "lat" = lat[(750  + 10 * lat_min):(750  + 10 * lat_max)]
)

crop_temp <- nc_temp |> nc_crop(lon_min, lon_max, lat_min, lat_max)

crop_u_lowres <- nc_u |>
  nc_crop(lon_min, lon_max, lat_min, lat_max) |> 
  reduce_density(2)

crop_v_lowres <- nc_v |>
  nc_crop(lon_min, lon_max, lat_min, lat_max) |> 
  reduce_density(2)

map_data_lowres_df <- crop_lonlat |>
  mutate("temp" = crop_temp, "u" = crop_u_lowres, "v" = crop_v_lowres)

current_uv_scalar <- 2 # Set scalar for better vector visibility, don"t forget when setting scale in final graph
```

##### Landmass

```{r}
# Setting up landmass map from naturalearth
states <- ne_states(
  country     = c("united states of america", "mexico"),
  returnclass = "sf"
)

# Sampling site coordinates and misc info on map
sample_sites <- read.csv(
    here("data","EJA_RAD_sampling_sites.csv"),
    stringsAsFactors = FALSE
  ) |>
  filter(!duplicated(Sampling_location)) |> 
  mutate( # Add offsets
    "lab_lon" = Longitude + .15 + c(0, 0, 0, .1, 0, 0, 0, -.1 -2),
    "lab_lat" = Latitude + .25 + c(0, -.5, 0, -.2, 0, 0, 0, -.1 -1)
  )

states_labels <- data.frame(
  "long" = c(-117.5, -115.5, -113.7, -115.2),
  "lat"  = c(35.5, 36.6, 35, 30.25),
  "lab"  = c("CA", "NV", "AZ", "BC")
)
city_labels <- data.frame(
  "lat"      = c(37.773972, 34.448113),
  "long"     = c(-122.431297, -120.471439),
  "lat_lab"  = c(37.9, 34.8),
  "long_lab" = c(-122.28, -120.535),
  "lab"      = c("San Francisco", "Point\nConception")
)
ocean_labels <- data.frame(
  "long" = c(-121,-113.85),
  "lat"  = c(31,30.7),
  "lab"  = c("Pacific Ocean","Gulf\nof\nCalifornia")
)
```

#### Generate map

[Tutorial for surface temperature and current speed map](https://theoceancode.netlify.app/post/mapping_with_ggplot2/)

```{r}
map <- ggplot() +
  # Temperature map
  geom_tile(
    mapping = aes(x = lon, y = lat, fill = temp),
    data    =  map_data_lowres_df
  ) +
  # Temperature scale
  scale_fill_viridis(name = "Temp.\n(°C)", option = "turbo") +
  # Current vectors
  geom_segment(
    data    = map_data_lowres_df,
    mapping = aes(
      x    = lon,
      y    = lat,
      xend = lon + current_uv_scalar * u,
      yend = lat + current_uv_scalar * v
    ),
    arrow   = arrow(angle = 15, length = unit(0.035, "inches"), type = "closed"),
    na.rm   = TRUE,
    alpha   = 0.3
  ) +
  # Landmass
  geom_sf(data = states) +
  # Crop map
  coord_sf(xlim = c(-124, -113), ylim = c(28.5, 38.5), expand = FALSE) +
  # Sampling sites points and labels
  new_scale("fill") +
  geom_path( # Path from Catalina label to Catalina island
    data.frame(
      "x" = c(-118.4163, -118.4163 -.85),
      "y" = c(33.38790, 33.38790 -.73)
    ),
    mapping = aes(x, y)
  ) +
  geom_point(
    sample_sites,
    mapping     = aes(
      x = Longitude,
      y = Latitude,
      fill = Sampling_location,
      size = 1.3
    ),
    shape       = 21,
    show.legend = FALSE
  ) +
  geom_label(
    sample_sites,
    mapping = aes(x = lab_lon, y = lab_lat, label = Sampling_location),
    hjust   = 0
  ) +
  # Extra cities points and labels
  geom_point(
    city_labels,
    mapping     = aes(x = long, y = lat),
    size        = 4,
    shape       = 20,
    show.legend = FALSE
  ) +
  geom_text(
    city_labels,
    mapping    = aes(x = long_lab, y = lat_lab, label = lab),
    lineheight = .7,
    hjust      = 0
  ) +
  # Ocean and state names
  geom_text(
    states_labels,
    mapping = aes(x = long, y = lat, label = lab),
    size = 5.5
  ) +
  geom_text(
    ocean_labels[2, ],
    mapping = aes(x = long, y = lat, label = lab),
    colour  = "ivory",
    size    = 5
  ) +
  geom_label(
    ocean_labels[1, ],
    mapping       = aes(x = long, y = lat, label = lab),
    colour        = "black",
    size          = 5,
    label.padding = unit(0.5, "lines")
  ) +
  # Vector scale
  geom_label(
    aes(x = -122, y = 29.5, label = "1.0 m/s\n"),
    size          = 4.5,
    label.padding = unit(0.5, "lines")
  ) +
  geom_segment(
    aes(x = -122.5, y = 29.25, xend = -121.5, yend = 29.25),
    arrow = arrow(angle = 15, length = unit(0.035, "inches"), type = "closed")
  ) +
  # Cartographic scale
  geom_label(aes(x = -119.1, y = 28.71, label = "        ")) +
  annotation_scale(location = "bl", width_hint = 0.4) +
  # Orientation
  annotation_north_arrow(
    location = "tr",
    style = north_arrow_fancy_orienteering()
  ) +
  # Axes
  labs(x = "Longitude", y = "Latitude") +
  scale_x_continuous(
    breaks = c(-120, -115),
    labels = c("120°W", "115°W")
  ) +
  scale_y_continuous(
    breaks = c(30, 35),
    labels = unit_format(suffix = "°N", sep = "")
  )

save_open_plot(
  here("output", "plots", "temp_current_map.pdf"),
  plot   = map,
  width  = 9,
  height = 9
)
```

### Memory cleanup

```{r}
rm(nc_temp, nc_u, nc_v,
   lon, lat,
   crop_temp, crop_u_lowres, crop_v_lowres,
   map, states,
   sample_sites, states_labels, city_labels, ocean_labels,
   current_uv_scalar)
gc()
```

### Fuse PCA plot and map

```{r}
PCA_map <- ggarrange(PCA, map, widths = c(1, 1.3))

save_open_plot(
  here("output", "plots", "pca_map.pdf"),
  plot   = PCA_map,
  width  = 14,
  height = 9
)
```

## Figure 3? - Bathymetry

### Generating bathymetry map

#### Getting and formatting data

```{r}
nc_u   <- nc_open(here("data", "ocean_u_ann_2022.nc"))
nc_v   <- nc_open(here("data", "ocean_v_ann_2022.nc"))

crop_u <- nc_u |>
  nc_crop(lon_min, lon_max, lat_min, lat_max)
crop_v <- nc_v |>
  nc_crop(lon_min, lon_max, lat_min, lat_max)
```

```{r}
catalina_df <-
  getNOAA.bathy(
    lon1 = -121,
    lon2 = -116,
    lat1 = 32,
    lat2 = 35,
    resolution = .5
  ) |> 
  fortify.bathy() |>
  mutate(z = ifelse(z > 0, NA, z)) # Remove landmass data

map_data_df <- data.frame( # Get surface current vectors
  crop_lonlat,
  "u" = crop_u,
  "v" = crop_v
)
```

#### Generate map

```{r}
bathy <- ggplot() +
  # Plot bathymetry
  geom_raster(data = catalina_df, mapping = aes(x = x, y = y, fill = z)) +
  # Plot landmass
  geom_sf(data = states) +
  # Plot surface current speed
  geom_segment(
    data    = map_data_df,
    mapping = aes(x = lon, y = lat, xend = lon + u * 1, yend = lat + v * 1),
    arrow   = arrow(angle = 15, length = unit(0.04, "inches"), type = "closed"),
    na.rm   = TRUE,
    alpha   = 0.3
  ) +
  # Plot sampling sites
  geom_point(
    sample_sites[c(3,4,5,8),],
    mapping     = aes(x = Longitude, y = Latitude, size = 1.3),
    show.legend = FALSE
  ) +
  geom_label(
    sample_sites[c(3,4,5,8),],
    mapping = aes(x = Longitude, y = Latitude, label = Sampling_location),
    hjust   = 0,
    nudge_x = .05,
    nudge_y = .1
  ) +
  # Plot extra landmark
  geom_point(
    city_labels[2, ],
    mapping     = aes(x = long, y = lat),
    size        = 4,
    shape       = 20,
    show.legend = FALSE
  ) +
  geom_text(
    city_labels[2, ],
    mapping = aes(x = long, y = lat, label = lab),
    lineheight = .7,
    hjust = 0,
    nudge_x = .05,
    nudge_y = .1
  ) +
  # Plot scales
  scale_fill_gradient(
    name = "Depth (m)",
    low = "dodgerblue4",
    high="gainsboro"
  ) +
  geom_label(
    aes(x = -120.4, y = 32.3, label = ".25 m/s\n"),
    size = 4.5,
    label.padding = unit(0.5, "lines")
  ) +
  geom_segment(
    aes(x = -120.52, y = 32.25, xend = -120.27, yend = 32.25),
    arrow = arrow(angle = 15, length = unit(0.04, "inches"), type = "closed")
  ) +
  geom_label(aes(x = -119.705, y = 32.08, label = "        ")) +
  annotation_scale(location = "bl", width_hint = 0.4) +
  annotation_north_arrow(
    location = "tr",
    style    = north_arrow_fancy_orienteering()
  ) +
  # Crop map
  coord_sf(xlim = c(-121, -116), ylim = c(32, 35), expand = FALSE) +
  # Axis labels and theme
  labs(x = "Longitude", y = "Latitude") +
  scale_y_continuous(
    breaks = seq(32, 35, 1),
    labels = unit_format(suffix = "°N", sep = "")
  ) +
  theme(
    legend.position = c(.93, .73),
    plot.margin     = margin(t = 0, r = 1, b = 0, l = .5, unit = "cm")
  )

save_open_plot(
  here("output", "plots", "bathy.pdf"),
  plot   = bathy,
  width  = 9,
  height = 7
)
```

## Blank map

```{r}
map_blank <- ggplot() +
  # Landmass
  geom_sf(data = states) +
  # Sampling sites points and labels
  new_scale("fill") +
  geom_path(
    mapping = aes(x, y),
    data    = data.frame(
      "x" = c(-118.4163, -118.4163 -.85),
      "y" = c(33.38790, 33.38790 -.73)
    )
  ) +
  geom_point(
    sample_sites,
    mapping     = aes(
      x    = Longitude,
      y    = Latitude,
      fill = Sampling_location,
      size = 1.3
    ),
    shape       = 21,
    show.legend = FALSE
  ) +
  geom_label(
    sample_sites,
    mapping = aes(x = lab_lon, y = lab_lat, label = Sampling_location),
    hjust   = 0
  ) +
  geom_point(
    city_labels,
    mapping     = aes(x = long, y = lat),
    size        = 4,
    shape       = 20,
    show.legend = FALSE
  ) +
  geom_text(
    city_labels,
    mapping    = aes(x = long_lab, y = lat_lab, label = lab),
    lineheight = .7,
    hjust      = 0
  ) +
  # Ocean and state names
  geom_text(
    states_labels,
    mapping = aes(x = long, y = lat, label = lab),
    size    = 5.5
  ) +
  geom_text(
    ocean_labels[2,],
    mapping = aes(x = long, y = lat, label = lab),
    colour  = "ivory",
    size    = 5
  ) +
  geom_label(
    ocean_labels[1,],
    mapping       = aes(x = long, y = lat, label = lab),
    colour        = "black",
    size          = 5,
    label.padding = unit(0.5, "lines")
  ) +
  # Crop map 
  coord_sf(xlim = c(-124, -113), ylim = c(28.5, 38.5), expand = FALSE) +
  # Vector, temperature and distance scale + orientation
  geom_label(aes(x = -119.1, y = 28.71, label = "        ")) +
  annotation_scale(location = "bl", width_hint = 0.4) +
  annotation_north_arrow(
    location = "tr",
    style = north_arrow_fancy_orienteering()
  ) +
  # Set text around map and coordinates display
  labs(x = "Longitude", y = "Latitude") +
  scale_x_continuous(
    breaks = c(-120, -115),
    labels = c("120°W","115°W")
  ) +
  scale_y_continuous(
    breaks = c(30, 35),
    labels = unit_format(suffix = "°N", sep = "")
  ) +
  theme(panel.background = element_rect("lightblue"))

save_open_plot(
  here("output", "plots", "map_blank.pdf"),
  plot   = map_blank,
  width  = 7.5,
  height = 7.5
)
```

## Figure 4? - Protein sequences annotation

### Convert blast KOALA pie piechart in barplot

```{r}
koala_results <- read.csv( # File downloaded from https://www.kegg.jp/blastkoala/ is expected
  here("external_results", "Blast_koala_results.csv"),
  stringsAsFactors = FALSE
) |>
  mutate(
    Functional.category = factor(Functional.category, Functional.category)
  )

koala_barplot <- ggplot(
    koala_results,
    mapping = aes(
      x    = Functional.category,
      y    = Counts,
      fill = Functional.category
    )
  ) +
  geom_col() +
  scale_fill_manual(
    name   = "Functional category",
    labels = koala_results$Functional.category,
    values = koala_results$colour,
    breaks = koala_results$Functional.category
  ) +
  theme(
    panel.background   = element_rect(fill = "white", colour = "black"),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_line(
      colour    = "black",
      linetype  = "solid",
      linewidth = .12
    ),
    panel.grid.minor.y = element_line(
      colour    = "black",
      linetype  = "dashed",
      linewidth = .08
    ),
    axis.ticks.x      = element_blank(),
    axis.text.x       = element_blank(),
    axis.title.x      = element_blank()
  )

save_open_plot(
  here("external_results", "blast_koala_bar_plot.pdf"),
  plot   = koala_barplot,
  width  = 8,
  height = 4
)
```
