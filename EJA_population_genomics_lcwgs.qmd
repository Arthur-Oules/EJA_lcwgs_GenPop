---
title: "EJA Population Genomics Low coverage"
author: "Arthur OulÃ¨s"
format: html
editor: source
---
# Load packages

```{r}
#| label: LoadPackages
#| echo: false

c("here", "tidyverse",
  "pcadapt", "vcfR", "adegenet", "ape", "LEA") |>
  lapply(library, character.only = TRUE)
```

# Load data analysis functions
```{r}
#| label: LoadTidy

source(here("functions", "lcwgs_tidy_functions.R"))
```

# pcadapt analysis

## All populations

### Convert vcf to bed file using plink2
```{bash}
cd C:/Users/aoules/Desktop/R_projects/Surfperch_GenPop/plink2

./plink2 --vcf 8-Embiotoca_filtered.vcf.gz --make-bed --out 8-Embiotoca_filtered
```

### Preanalysis to determine optimal K value
```{r}
#| label: PreAnalysis

EJA_lcwgs <- read.pcadapt(
  here("data", "SNPs", "8-Embiotoca_filtered.bed"),
  type = "bed"
)

pcadapt(input = EJA_lcwgs, K = 20) |>
  plot(option = "screeplot")
```

K = 4 seems correct

### Analysis using K = 4
```{r}
#| label: pcadapt

popmap_lcwgs <- c(
  rep("bodega_bay",            5), # BB
  rep("big_creek",            13), # BIGC -> BCR
  rep("catalina_island",      11), # CAT
  rep("elkhorn",               6), # ELK
  rep("guadalupe_island",     10), # GUA
  rep("pacific_grove",        13), # HOP -> Pacific Grove PGR 
  rep("isla_san_jeronimo",    11), # ISJ
  rep("laguna_beach",         13), # LB
  rep("point_dume",            5), # PD
  rep("santa_barbara_island", 13), # SB
  rep("san_clemente_island",  10), # SCL
  rep("la_jolla_san_diego",   13), # SD
  rep("tomales_bay",           1), # TB
  rep("redondo_beach",        10), # RB
  rep("santa_cruz_harbour",   10) # SCH
)

pcadapt_lcwgs <- EJA_lcwgs |> pcadapt(K = 4)
```

```{r}
#| eval: false

write_rds(pcadapt_lcwgs, file = here("output", "pcadapt_lcwgs.rds"))
```

### Exploratory plots
```{r}
#| label: ExploPlots

pcadapt_lcwgs |> plot(option = "scores", pop = popmap_lcwgs, i = 1, j = 2)
pcadapt_lcwgs |> plot(option = "scores", pop = popmap_lcwgs, i = 2, j = 3)
pcadapt_lcwgs |> plot(option = "scores", pop = popmap_lcwgs, i = 3, j = 4)

pcadapt_lcwgs |> plot(option = "qqplot")

pcadapt_lcwgs |> plot(option = "manhattan")

pcadapt_lcwgs$pvalues |> hist(
  xlab   = "p-values",
  main   = NULL,
  breaks = 50,
  col    = "orange"
)
```

## Generating whitelist
```{r}
#| label: Whitelist
#| eval: false

Indiv_list <- here("data", "EJA_lcwgs_gt.RDS") |>
  read_rds() |>
  _$Indiv

Indiv_list |>
  write_rds(file = here("data", "Individual_list.rds"))
```

```{r}
#| label: SaveWhitelist
#| eval: false

Indiv_list |> 
  unique() |>
  {\(x) {
    x[
      !(grepl(pattern = "SCL", x = x) |
        grepl(pattern = "GUA", x = x) |
        grepl(pattern = "CAT", x = x))
    ]
    }}() |> 
  write_lines(here("plink2", "whitelist_pipi.txt"))
```

## Excluding islanders
### Generating bed file
```{bash}
cd C:/Users/aoules/Desktop/R_projects/Surfperch_GenPop/plink2

./plink2 --bfile 8-Embiotoca_filtered --keep whitelist.txt --make-bed --out 8-Embiotoca_filtered_whitelisted
```

### Preanalysis to determine optimal K value
```{r}
#| label: CoastPreAnalysis
EJA_lcwgs_coast <- read.pcadapt(
  here("data", "SNPs", "8-Embiotoca_filtered_whitelisted.bed"),
  type = "bed"
)

pcadapt(input = EJA_lcwgs_coast, K = 20) |> plot(option = "screeplot")
```

K = 3 seems correct

### Analysis using K = 3
```{r}
#| label: Coastpcadapt

popmap_lcwgs_coast <- c(
  rep("bodega_bay",            5), # BB
  rep("big_creek",            13), # BIGC -> BCR
  rep("elkhorn",               6), # ELK
  rep("pacific_grove",        13), # HOP -> Pacific Grove PGR
  rep("isla_san_jeronimo",    11), # ISJ
  rep("laguna_beach",         13), # LB
  rep("point_dume",            5), # PD
  rep("santa_barbara_island", 13), # SB
  rep("la_jolla_san_diego",   13), # SD
  rep("tomales_bay",           1), # TB
  rep("redondo_beach",        10), # RB
  rep("santa_cruz_harbour",   10)  # SCH
)

pcadapt_lcwgs_coast <- EJA_lcwgs_coast |> pcadapt(K = 3)
```

```{r}
#| eval: false

write_rds(pcadapt_lcwgs_coast, file = here("output", "pcadapt_lcwgs_coast.rds"))
```

### Associated exploratory plots
```{r}
#| label: CoastExploPlots

coast_PCA_1_2 <- pcadapt_lcwgs_coast |>
  plot(option = "scores", pop = popmap_lcwgs_coast, i = 1, j = 2) +
  theme_minimal()

save_open_plot(
  here("output", "plots", "lcwgs", "coast_PCA_1_2.pdf"),
  plot   = coast_PCA_1_2,
  width  = 10,
  height = 8
)

coast_PCA_2_3 <- pcadapt_lcwgs_coast |>
  plot(option = "scores", pop = popmap_lcwgs_coast, i = 2, j = 3) +
  theme_minimal()

save_open_plot(
  here("output", "plots", "lcwgs", "coast_PCA_2_3.pdf"),
  plot   = coast_PCA_2_3,
  width  = 10,
  height = 8
)

pcadapt_lcwgs_coast |> plot(option = "qqplot") + theme_minimal()

coast_manhattan <- pcadapt_lcwgs_coast |>
  plot(option = "manhattan") +
  theme_minimal()

save_open_plot(
  here("output", "plots", "lcwgs", "coast_manhattan.pdf"),
  plot   = coast_manhattan,
  width  = 16,
  height = 4
)

pcadapt_lcwgs_coast$pvalues |> hist(
  xlab   = "p-values",
  main   = NULL,
  breaks = 50,
  col    = "orange"
)
```

```{r}
#| label: CoastMemclean

rm(EJA_lcwgs_coast)
```

## Only insular
### Generating bed file
```{bash}
cd C:/Users/aoules/Desktop/R_projects/Surfperch_GenPop/plink2

./plink2 --bfile 8-Embiotoca_filtered --remove whitelist.txt --make-bed --out 8-Embiotoca_filtered_blacklisted
```

### Preanalysis to determine optimal K value
```{r}
#| label: IslPreAnalysis

EJA_lcwgs_islands <- read.pcadapt(
  here("data", "SNPs", "8-Embiotoca_filtered_blacklisted.bed"),
  type = "bed"
)

pcadapt(input = EJA_lcwgs_islands, K = 2) |> plot(option = "screeplot")
```

### Analysis using K = 2
```{r}
#| label: Islpcadapt

popmap_lcwgs_islands <- c(
  rep("catalina_island", 11), # CAT
  rep("guadalupe_island", 10), # GUA
  rep("san_clemente_island", 10) # SCL
)

pcadapt_lcwgs_islands <- EJA_lcwgs_islands |> pcadapt(K = 2)
```

```{r}
#| eval: false

write_rds(pcadapt_lcwgs_islands, file = here("output", "pcadapt_lcwgs_islands.rds"))
```

### Associated exploratory plots

```{r}
#| label: IslExploPlots

islands_PCA_1_2 <- pcadapt_lcwgs_islands |>
  plot(option = "scores", pop = popmap_lcwgs_islands, i = 1, j = 2) +
  theme_minimal()

save_open_plot(
  here("output", "plots", "lcwgs", "islands_PCA_1_2.pdf"),
  plot   = islands_PCA_1_2,
  width  = 10,
  height = 8
)

pcadapt_lcwgs_islands |>
  plot(option = "qqplot") +
  theme_minimal()

islands_manhattan <- pcadapt_lcwgs_islands |>
  plot(option = "manhattan") +
  theme_minimal()

save_open_plot(
  here("output", "plots", "lcwgs", "islands_manhattan.pdf"),
  plot   = islands_manhattan,
  width  = 16,
  height = 4
)

pcadapt_lcwgs_islands$pvalues |> hist(
  xlab   = "p-values",
  main   = NULL,
  breaks = 50,
  col    = "orange"
)
```

## San Diego vs Santa Cruz

```{r}
#| label: SaveWhitelist
#| eval: false

Indiv_list <- read_rds(file = here("data", "Individual_list.rds"))

Indiv_list |> 
  unique() |>
  {\(x) {
    x[
      (grepl(pattern = "SCH", x = x) |
       grepl(pattern = "SD", x = x))
    ]
    }}() |> 
  write_lines(here("plink2", "whitelist_SD_SC.txt"))
rm(Indiv_list)
```

```{bash}
cd C:/Users/aoules/Desktop/R_projects/Surfperch_GenPop/plink2

./plink2 --bfile 8-Embiotoca_filtered --keep whitelist_SD_SC.txt --make-bed --out 8-Embiotoca_filtered_SD_SC
```

```{r}
#| label: PreAnalysisSDSC

EJA_lcwgs_SD_SC <- read.pcadapt(
  here("plink2", "SNPs", "8-Embiotoca_filtered_SD_SC.bed"),
  type = "bed"
)

pcadapt(input = EJA_lcwgs_SD_SC, K = 20) |>
  plot(option = "screeplot")
```

K = 4 seems correct

```{r}
#| label: pcadapt

popmap_lcwgs_SD_SC <- c(
  rep("la_jolla_san_diego", 13), # SD
  rep("santa_cruz_harbour", 10) # SCH
)

pcadapt_lcwgs_SD_SC <- EJA_lcwgs_SD_SC |> pcadapt(K = 1)
```


```{r}
#| label: ExploPlots

pcadapt_lcwgs_SD_SC |> plot(option = "qqplot")

pcadapt_lcwgs_SD_SC |> plot(option = "manhattan")

pcadapt_lcwgs_SD_SC$pvalues |> hist(
  xlab   = "p-values",
  main   = NULL,
  breaks = 50,
  col    = "orange"
)
```

# Outliers

## Get outliers sequences

### Prepare all data
```{r}
EJA_lcwgs_vcf <- read_rds(here("data", "EJA_lcwgs_vcfR.RDS"))
```

```{r}
#| label: GenomeMap
#| echo: false

SNP_positions <- EJA_lcwgs_vcf |>
  getFIX() |>
  as_tibble() |>
  select(CHROM, POS) |>
  mutate(POS = as.numeric(POS))

saveRDS(SNP_positions, file = here("data", "SNP_positions.rds"))

rm(EJA_lcwgs_vcf, SNP_positions)
```

### Read genome
```{r}
lcwgs_catalog <- read.dna(
    here("data", "JAKOON01_catalog", "catalog.fa"),
    format = "fasta",
    as.character = TRUE
  )

names(lcwgs_catalog) <- names(lcwgs_catalog) |>
  str_split(pattern = " ") |>
  map(\(x) x[1]) |>
  unlist()
```

### Adjusted pvalues

```{r}
alpha <- 0.1
outliers <- which(padj < alpha)
length(outliers)
```

### Get pvalues map from coastal individuals analysis
```{r}
pcadapt_lcwgs_coast <- readRDS(here("output", "pcadapt_lcwgs_coast.rds"))

pvalues_positions <- readRDS(
  file = here("data", "SNP_positions.rds")
) |> 
  select(-c(lab_position, coloured, rank)) |> 
  mutate(
    pvalues    = pcadapt_lcwgs_coast$pvalues,
    logpvalues = Get_pvalues(pcadapt_lcwgs_coast)
  )

pvalues_positions_filtered <- pvalues_positions |> 
  filter(is.na(pvalues) == FALSE) |> 
  filter(logpvalues >= 200)

pvalues_positions_filtered_dup <- pvalues_positions_filtered |> 
  mutate(dist = c(0, diff(POS))) |> 
  filter(dist >= 500) |>
  select(-c(dist))
  
```

### Get corresponding read windows
```{r}
chromosomes_length <- read_tsv(here("data", "JAKOON01_catalog", "JAKOON01_contigs.tsv"))

pvalues_positions_filtered_dup_sequences <- pvalues_positions_filtered_dup |>
  mutate(
    sequences = row_number() |>
      map(
        \(x) lcwgs_catalog[[CHROM[[x]]]][Get_window(CHROM[[x]], POS[[x]])] |>
          paste(collapse = "") |>
          toupper()
      ) |> 
      unlist()
    )
```

### Write to fasta files
```{r}
pvalues_positions_filtered_dup_sequences |>
  mutate(seq_name = paste0(">", CHROM, " POS: ", as.character(POS))) |>
  select(seq_name, sequences) |> 
  filter(row_number() %in% 1:200) |> 
  write.table(
    file      = here("output", "lcwgs_outliers_sequences_1.fa"),
    sep       = "\n",
    row.names = FALSE,
    col.names = FALSE,
    quote     = FALSE
  )

pvalues_positions_filtered_dup_sequences |>
  mutate(seq_name = paste0(">", CHROM, " POS: ", as.character(POS))) |>
  select(seq_name, sequences) |> 
  filter(row_number() %in% 201:400) |> 
  write.table(
    file      = here("output", "lcwgs_outliers_sequences_2.fa"),
    sep       = "\n",
    row.names = FALSE,
    col.names = FALSE,
    quote     = FALSE
  )

pvalues_positions_filtered_dup_sequences |>
  mutate(seq_name = paste0(">", CHROM, " POS: ", as.character(POS))) |>
  select(seq_name, sequences) |> 
  filter(row_number() %in% 401:456) |> 
  write.table(
    file      = here("output", "lcwgs_outliers_sequences_3.fa"),
    sep       = "\n",
    row.names = FALSE,
    col.names = FALSE,
    quote     = FALSE
  )
```

```{r}
rm(chromosomes_length,
   pvalues_positions, pvalues_positions_filtered,
   pvalues_positions_filtered_dup_sequences)
gc()
```

## Extract outliers annotations from ncbi genome annotations

### Load external info

```{r}
EJA_annotations <- here("data", "EJA_annotations.gff") |>
  read.gff() |>
  as_tibble()

chromosomes_info <- here("data", "JAKOON01_catalog", "sequence_report.tsv") |> 
  read_tsv() |>
  select(c(`GenBank seq accession`, `RefSeq seq accession`))
```

### Get annotations

```{r}
pvalues_positions_filtered_dup_annotations <- pvalues_positions_filtered_dup |>
  Get_annotations(
    chrom_info     = chromosomes_info,
    gff_annotation = EJA_annotations
  )
```

### Memory cleanup

```{r}
rm(EJA_annotations, chromosomes_info, pvalues_positions_filtered_dup)
gc()
```

### Sort and filter info

```{r}
pvalues_positions_filtered_dup_annotations_genes <- pvalues_positions_filtered_dup_annotations |> 
  unnest(annotation) |> 
  filter(grepl("ID=gene", annotation)) |> 
  mutate(
    annotation_ID          = annotation |>
      str_split_i(pattern = ";", i = 1) |> 
      str_remove(pattern = "ID="),
    annotation_description = annotation |>
      str_split_i(pattern = ";", i = 4) |> 
      str_remove(pattern = "description=")
  ) |> 
  select(-c(annotation)) |> 
  distinct(annotation_ID, .keep_all = TRUE)

pvalues_positions_filtered_dup_annotations_rnas <- pvalues_positions_filtered_dup_annotations |> 
  unnest(annotation) |> 
  filter(grepl("ID=rna", annotation)) |> 
  mutate(
    annotation_ID      = annotation |>
      str_split_i(pattern = ";", i = 1) |> 
      str_remove(pattern = "ID="),
    annotation_product = annotation |>
      str_match("product=\\s*(.*?)\\s*;") |> 
      _[, 2]
  ) |> 
  select(-c(annotation)) |> 
  distinct(annotation_ID, .keep_all = TRUE)

pvalues_positions_filtered_dup_annotations_exons <- pvalues_positions_filtered_dup_annotations |> 
  unnest(annotation) |> 
  filter(grepl("ID=exon", annotation)) |> 
  mutate(
    annotation_ID      = annotation |>
      str_split_i(pattern = ";", i = 1) |> 
      str_remove(pattern = "ID="),
    annotation_gene    = annotation |>
      str_match("gene=\\s*(.*?)\\s*;") |> 
      _[, 2],
    annotation_product = annotation |>
      str_match("product=\\s*(.*?)\\s*;") |> 
      _[, 2]
  ) |> 
  select(-c(annotation)) |> 
  distinct(annotation_ID, .keep_all = TRUE)

pvalues_positions_filtered_dup_annotations_cds <- pvalues_positions_filtered_dup_annotations |> 
  unnest(annotation) |> 
  filter(grepl("ID=cds", annotation)) |> 
  mutate(
    annotation_ID      = annotation |>
      str_split_i(pattern = ";", i = 1) |> 
      str_remove(pattern = "ID="),
    annotation_gene    = annotation |>
      str_match("gene=\\s*(.*?)\\s*;") |> 
      _[, 2],
    annotation_product = annotation |>
      str_match("product=\\s*(.*?)\\s*;") |> 
      _[, 2]
  ) |> 
  select(-c(annotation)) |> 
  distinct(annotation_ID, .keep_all = TRUE)

pvalues_positions_filtered_dup_annotations_all <- bind_rows(
  pvalues_positions_filtered_dup_annotations_genes,
  pvalues_positions_filtered_dup_annotations_rnas,
  pvalues_positions_filtered_dup_annotations_exons,
  pvalues_positions_filtered_dup_annotations_cds
) |> 
  mutate(
    annotation_type        = annotation_ID |> str_split_i(pattern = "-", i = 1),
    annotation_ID          = annotation_ID |> str_split_i(pattern = "-", i = 2),
    annotation_description = annotation_description |>
      str_remove_all(pattern = "%2C"),
    annotation_product     = annotation_product |>
      str_remove_all(pattern = "%2C")
  ) |>
  select(
    c("GenBank seq accession", "POS",
      "RefSeq seq accession", "annotation_type", "annotation_ID",
      "annotation_description", "annotation_product", "annotation_gene",
      "pvalues", "logpvalues")
  ) |> 
  arrange(pvalues, `GenBank seq accession`, POS)
```

### Save as file and cleanup

```{r}
pvalues_positions_filtered_dup_annotations_all |>
  write_csv2(here("output", "lcwgs_EJA_outliers_annotations.csv"))

rm(pvalues_positions_filtered_dup_annotations_genes,
   pvalues_positions_filtered_dup_annotations_rnas,
   pvalues_positions_filtered_dup_annotations_exons,
   pvalues_positions_filtered_dup_annotations_cds)
```

## Get BLAST results

```{r}
pvalues_positions <- pvalues_positions |>
  mutate(Rank = paste0(CHROM, " POS: ", as.character(POS)))

lcwgs_EJA_outliers_blast_tib <- c("GZSEDPGT016-Alignment.xml",
                                  "GZSJHA6W016-Alignment.xml",
                                  "GZSMYB0J016-Alignment.xml") |> # "Single-file XML2" file from NCBI BLASTn output is expected
  here("data", ) |>
  map( \(x) read_xml(x) |> XML_to_df()) |> 
  bind_rows() |>
  left_join(pvalues_positions)

rm(pvalues_positions)
```
### Filter BLAST results

```{r}
lcwgs_EJA_outliers_blast_tib_filtered <- lcwgs_EJA_outliers_blast_tib |>
  filter(bit_score >= 80) |> 
  filter(!grepl("genome assembly", title)) |> 
  filter(!duplicated(Rank)) |> # Keep the first match for each locus
  filter(!duplicated(accession_number))
```

```{r}
write_csv2(
  lcwgs_EJA_outliers_blast_tib_filtered,
  file = here("output", "lcwgs_outliers_match.csv")
)
```

### Get protein sequences from GenBank
```{r}
lcwgs_protein_sequences <- lcwgs_EJA_outliers_blast_tib_filtered |> Get_protein_sequences()
```

### Save output as fasta file which can be sent to [blast KOALA](https://www.kegg.jp/blastkoala/).

```{r}
lcwgs_protein_sequences |> 
  mutate(accession_number = paste0("> ", accession_number)) |>
  write.table(
    file      = here("output", "lwcgs_EJA_outliers_protein_sequences.fa"),
    sep       = "\n",
    row.names = FALSE,
    col.names = FALSE,
    quote     = FALSE
  )
```

## Get BLAST results A. ocellaris

```{r}
pvalues_positions <- readRDS(
  file = here("data", "SNP_positions.rds")
) |> 
  mutate(
    pvalues = pcadapt_lcwgs_coast$pvalues,
    logpvalues = Get_pvalues(pcadapt_lcwgs_coast)
  ) |>
  mutate(Rank = paste0(CHROM, " POS: ", as.character(POS)))
```

```{r}
lcwgs_EJA_outliers_blast_A_ocellaris_tib <- c("HFHS4UE9013-Alignment.xml",
                                              "HFHRYX38013-Alignment.xml",
                                              "HFHSG8SF016-Alignment.xml") |> # "Single-file XML2" file from NCBI BLASTn output is expected
  here("data", ) |>
  map( \(x) read_xml(x) |> XML_to_df()) |> 
  bind_rows() |>
  left_join(pvalues_positions)

rm(pvalues_positions)
```

```{r}
lcwgs_EJA_outliers_blast_A_ocellaris_tib_filtered <- lcwgs_EJA_outliers_blast_A_ocellaris_tib |>
  filter(bit_score >= 80) |> 
  filter(!grepl("genome assembly", title)) |> 
  filter(!duplicated(Rank)) |> # Keep the first match for each locus
  filter(!duplicated(accession_number))

lcwgs_EJA_outliers_blast_A_ocellaris_tib_filtered |> write.csv2(here("output", "lcwgs_outliers_match_A_ocellaris.csv"))
```


# Admixture analysis

## Convert data to ped format for LEA import using plink2
```{bash}
cd C:/Users/aoules/Desktop/R_projects/Surfperch_GenPop/plink2
./plink2 --vcf 8-Embiotoca_filtered.vcf.gz --export ped --out 8-Embiotoca_filtered
```

## Read and convert data
```{r}
#| label: VcfConvert
#| eval: false

EJA_lcwgs_vcf <- here("data", "SNPs", "8-Embiotoca_filtered.vcf.gz") |> read.vcfR()

EJA_lcwgs_vcf |> write_rds(here("data", "EJA_lcwgs_vcfR.RDS"))

ped2geno(
  input.file  = here("plink2", "SNPs", "8-Embiotoca_filtered.ped"),
  output.file = here("data", "SNPs", "8-Embiotoca_filtered.geno")
)

rm(EJA_lcwgs_vcf)
```

## Run analysis
```{r}
#| label: snmfAnalysisSingle

snmf_analysis <- snmf(
  here("data", "SNPs", "8-Embiotoca_filtered.geno"),
  K           = 4:8,
  project     = "continue",
  repetitions = 50,
  entropy     = TRUE
)
```

## Plot cross entropy to chose optimal value of K
```{r}
#| label: snmfSinglePlot

plot(snmf_analysis)

snmf_tb <- tibble(K = as.numeric(unique(snmf_analysis@K)))

cross_entropy <- rep(0, dim(snmf_tb)[1])

for (i in 1:length(snmf_tb$K)) {
  cross_entropy[i] <- min(cross.entropy(snmf_analysis, K = snmf_tb$K[i]))
}

snmf_plot <- snmf_tb |> mutate(cross_entropy = cross_entropy) |> 
  ggplot() +
  geom_point(aes(x = K, y = cross_entropy)) +
  theme_classic()

ggsave(
  filename = here("output", "plots", "lcwgs", "snmf_cross_entropy.png"),
  plot     = snmf_plot,
  width    = 8,
  height   = 5
)
```

K = 7 has the minimum cross-entropy. Previous results converged to K = 6 so this is confusing.

## Plot results for K = 6
```{r}
#| label: snmfAnalysisMultiPlot

# barchart(
#   snmf_analysis,
#   K         = 6,
#   run       = which.min(cross.entropy(snmf_analysis, K = 6)),
#   col       = turbo(n = 6),
#   sort.by.Q = FALSE
# )

barchart(
  snmf_analysis,
  K         = 7,
  run       = which.min(cross.entropy(snmf_analysis, K = 7)),
  col       = viridis::turbo(n = 6),
  sort.by.Q = FALSE
)
```